{"version":3,"sources":["../../app-src/util/HttpService.js"],"names":["HttpService","_handleErrors","res","ok","Error","statusText","get","url","fetch","then","json"],"mappings":";;;;;;gBAAaA,W,GAAN,MAAMA,WAAN,CAAkB;;AAErBC,8BAAcC,GAAd,EAAkB;AACd,wBAAG,CAACA,IAAIC,EAAR,EAAY,MAAM,IAAIC,KAAJ,CAAUF,IAAIG,UAAd,CAAN;AACZ;AACA,2BAAOH,GAAP;AACH;;AAEDI,oBAAIC,GAAJ,EAAQ;AACJ,2BAAOC,MAAMD,GAAN,EACME,IADN,CACWP,OAAO,KAAKD,aAAL,CAAmBC,GAAnB,CADlB,EAC2C;AAD3C,qBAEMO,IAFN,CAEWP,OAAOA,IAAIQ,IAAJ,EAFlB,CAAP,CADI,CAGiC;AACxC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BqB,a","file":"HttpService.js","sourcesContent":["export class HttpService {\r\n\r\n    _handleErrors(res){\r\n        if(!res.ok) throw new Error(res.statusText)\r\n        //se não estiver ok, lança uma exceção, caso contrário retorna a própria resposta\r\n        return res\r\n    }\r\n\r\n    get(url){\r\n        return fetch(url)\r\n                    .then(res => this._handleErrors(res)) //verifica se a requisição será realizada\r\n                    .then(res => res.json()) //res.json() retorna automáticamente para a próxima chamada encadeada a .then\r\n    }\r\n\r\n    //reescrito no cap.19.6 para utilizar API FETCH\r\n    // get (url) {\r\n    //     return new Promise((resolve, reject) => {\r\n    //         const xhr = new XMLHttpRequest()\r\n    //         xhr.open('GET', url)\r\n    //         xhr.onreadystatechange = () => {\r\n    //             if(xhr.readyState == 4){\r\n    //                 if(xhr.status == 200){\r\n    //                     //resultado passado já parseado para o RESOLVE\r\n    //                     resolve(JSON.parse(xhr.responseText))\r\n    //                 } else {\r\n    //                     reject(xhr.responseText)\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //         xhr.send()\r\n    //     })\r\n    // }\r\n}"]}